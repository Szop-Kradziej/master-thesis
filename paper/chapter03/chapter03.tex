\chapter{Koncepcja rozwiązania}
\label{chapter:requirements}

W ramach rozdziału omówiono założenia projektowe oraz koncepcję platformy.
Pierwszy podrozdział opisuje sposób testowania wybrany do weryfikacji programów studentów w ramach narzędzia.
W kolejnych podrozdziałach przedstawiono problemy, na jakie napotykają prowadzący i studenci podczas uczestnictwa w projekcie informatycznym.
Dla każdej z wymienionych trudności opisano sposób jej załagodzenia z wykorzystaniem zaimplementowanej w ramach pracy platformy.
W przedostatniej sekcji omówiono wymagania niefunkcjonalne dla narzędzia.
Ostatni podrozdział zawiera opis ograniczeń proponowanego rozwiązania.

\section{Sprawdzenie poprawności działania programów studentów}

W celu oceny poprawności działania programów studentów należy przeprowadzić odpowiednie testy.
Jedną z kategorii podziału testów, jest klasyfikacja ze względu na wiedzę na temat testowanego programu.
W tym przypadku wyróżniamy dwie podstawowe kategorie:
\begin{itemize}
    \item testy czarnej skrzynki (ang. black box testing),
    \item testy białej skrzynki (ang. white box testing).
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width = 13cm]{chapter02/black-box.png}
    \caption{Schemat testu czarnej skrzynki (źródło własne).}
    \label{fig:black-box}
\end{figure}

Na rysunku \ref{fig:black-box} został przedstawiony ogólny schemat procesu dla black box testów.
Dla tego przypadku fragment kodu lub cały testowany program nie jest znany dla testera.
Black box testing może odnosić się zarówno do testów funkcjonalnych, jak i niefunkcjonalnych.
Najczęściej jednak dotyczy on pierwszego rodzaju.
Na rysunku \ref{fig:tests-levels} zostały przedstawione poziomy testów.
Testy czarnej skrzynki mają zastosowanie na następujących poziomach:
\begin{itemize}
    \item testów integracyjnych,
    \item testów systemowych,
    \item testów akceptacyjnych.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width = 7cm]{chapter02/tests_levels.jpg}
    \caption{Poziomy testów (źródło: \cite{tests-levels}).}
    \label{fig:tests-levels}
\end{figure}

Ten rodzaj testów jest wykonywany z perspektywy użytkownika.
Pozwala to między innymi na wskazanie rozbieżności pomiędzy wytworzonym kodem a założoną specyfikacją zadania w tym:
\begin {itemize}
    \item niepoprawnych lub brakujących funkcjonalności,
    \item błędów w interfejsie,
    \item błędów w strukturach danych,
    \item błędów zachowania programów oraz wydajnościowych.
\end{itemize}
Zaletą tego rodzaju podejścia jest fakt, że osoba testująca nie musi znać kodu oraz języka programowania, w którym została napisana aplikacja.

\begin{figure}[h]
    \centering
    \includegraphics[width = 13cm]{chapter02/white-box.png}
    \caption{Schemat testu białej skrzynki (źródło własne).}
    \label{fig:white-box}
\end{figure}

Drugim rodzajem testowania programów jest metoda białej skrzynki (ang. white box testing).
Schemat procesu tego typu został przedstawiony na rysunku \ref{fig:white-box}.
W tym przypadku tester zna pełną implementację badanej funkcjonalności.
Jego zadaniem jest dobranie odpowiednich wartości wejściowych dla sprawdzanej funkcjonalności i uzyskanie założonych wartości wyjściowych, w ramach testowanego kodu.
Do realizacji tego zadania niezbędne są umiejętności programistyczne i wiedza na temat implementacji.
Testy białej skrzynki mają zastosowanie na następujących poziomach:
\begin{itemize}
    \item testów jednostkowych,
    \item testów integracyjnych,
    \item testów systemowych.
\end{itemize}
Warto jednak zaznaczyć, że ten typ testów używany jest głównie w testach jednostkowych.

Dzięki takiemu podejściu programiści mogą uzyskać bardzo szybką informację zwrotną.
Pozwala ono także na szczegółowe przetestowanie aplikacji.
Jednak poprawne napisanie testów jednostkowych jest bardziej złożone i wymaga dobrych umiejętności programistycznych.
Z założenia testów jednostkowych jest więcej niż integracyjnych czy akceptacyjnych i dla częstych zmian implementacji (co jest bardzo prawdopodobne na początkowym etapie nauki programowania) utrzymanie white box testów może okazać się bardzo kłopotliwe, a nawet wręcz niemożliwe dla studentów.
Warto też zauważyć, że testy jednostkowe są ściśle związane z implementacją, a więc z językiem programowania, w którym został napisany program.
W celu dodatnia testów najniższego poziomu należałoby posłużyć się dodatkową biblioteką, która byłaby wspierana przez dany język.
Poznanie zewnętrznych bibliotek i zaznajamianie się z ich interfejsami na początkowej drodze nauki programowania mogłoby przynieść negatywne rezultaty.
Studenci, zamiast skupić się na zrozumieniu podstaw programowania, zmuszeni byliby do poznania bibliotek, dla których nie rozumieliby w pełni słuszności zastosowania.

Przy użyciu platformy w przypadku jednakowych, wieloetapowych projektów prowadzący ma możliwość przygotowania szeregu przypadków testowych, które następnie zostaną użyte do sprawdzenia poprawności programów studentów.
Narzędzie udostępnia je studentom, dzięki czemu mają oni możliwość samodzielnie, lokalnie przetestować swój kod, przed ostateczną prezentacją prowadzącemu.
Taki proces sprawdzania programów studentów dla zadanych przypadków testowych jest automatyczny.
Dzięki temu studenci mogą w prosty sposób wielokrotnie uruchamiać te same testy dla nowych wariantów swoich programów.
Mają również możliwość uczenia się poprawnego definiowania przypadków testowych poprzez analizę testów akceptacyjnych.
Opisany sposób testowania leży na poziomie testów akceptacyjnych w formie testów czarnej skrzynki.

\section{Redukcja czasochłonności}

Podstawowym zadaniem platformy jest zredukowanie czasochłonności procesu weryfikacji pracy studentów wynikającej z indywidualnego podejścia przy rozpatrywaniu cząstkowych rezultatów dla każdej z grup.
To założenie można osiągnąć poprzez automatyzację procesu sprawdzania wyników wykonania programów w ramach kolejnych etapów.
Automatyzacja sprowadza się do utworzenia szeregu przypadków testowych przez prowadzącego w ramach każdego z etapów.
Następnie przeprowadzane są testy akceptacyjne na programach napisanych przez studentów.
Wyniki testów są jednoznaczne i znane zarówno dla prowadzącego, jak i studentów.
Jeśli wszystkie testy zakończą się sukcesem, to dana grupa zalicza w pełni zadany etap.
W przypadku, gdy któryś z testów zakończy się błędem, aplikacja studencka nie spełnia wszystkich założeń projektowych.
Na podstawie znajomości ilości i rodzaju testów, które zakończyły się niepoprawnie, prowadzący ma jasną sytuację co do postępów pracy danego zespołu dla zadanego zadania.
Te same testy służą do weryfikacji cząstkowej pracy każdej z grup, dzięki czemu prowadzący nie musi już indywidualnie oceniać poprawności programów.

Wymuszenie usunięcia indywidualnego podejścia do grup nie jest w pełni możliwe i~wskazane.
Obecnie w ramach każdego etapu studenci udostępniają swoje sprawozdania z postępów prac prowadzącym.
Analiza i ocena dokumentów odbywa się indywidualnie dla każdej grupy.
Studenci zamieszczają sprawozdania korzystając z systemu kontroli wersji.
Dokumenty jednak nie zawsze znajdują się w jasno określonym, intuicyjnym miejscu w repozytorium, a odnalezienie ich zajmuje zbędny czas.
Również w przypadku kodu programu niejednokrotnie ciężko stwierdzić, która wersja jest ostateczna dla zadanego etapu.
W celu ułatwienia oceny pracy studentów na interfejsie webowym platformy są zgrupowane w jednym, intuicyjnym miejscu trzy elementy cząstkowej pracy studentów pozwalające na jej ocenę: program wykonywalny, link do kodu aplikacji oraz sprawozdanie.
Dzięki łatwemu dostępowi do tych elementów prowadzący uniknie błędów podczas oceniania etapu.


\section{Informacja zwrotna}

Aktualnie informacja zwrotna dotycząca wyniku uzyskanego dla zadanego podzadania jest przekazywana studentom na zakończenie etapu.
Jest to stosunkowo późny moment.
Uzyskanie informacji zwrotnej przez grupę można przyspieszyć, udostępniając jej narzędzie pozwalające na wielokrotne sprawdzenie działania programu przy użyciu zdefiniowanych przez prowadzących testów akceptacyjnych.
Umożliwiając studentom samodzielne sprawdzenie ich aplikacji, pozwalamy im na zdobycie w szybszym czasie informacji o nieprawidłowościach w ich programie.
Dzięki temu studenci mają czas na eliminację błędów i doprecyzowanie założeń na wstępnym etapie implementacji danego etapu.
Studenci powinni mieć wgląd do pełnej definicji wszystkich przypadków testowych, aby mogli lepiej zrozumieć błędne działanie swoich aplikacji.
Wśród informacji zwrotnej dla każdego z~testów znajdują się:
\begin{itemize}
    \item dane wejściowe,
    \item oczekiwane dane wyjściowe oraz zwrócony wynik,
    \item status,
    \item logi aplikacji.
\end{itemize}

Zaimplementowane narzędzie umożliwia pozyskanie powyżej opisanych informacji zwrotnych w krótkim czasie i bez udziału prowadzącego.


\section{Praca w ramach etapów i integracji}

Jednym z zadań grupy studentów korzystającej z platformy jest między innymi zamieszenie na niej wyników swojej pracy dla kolejnych etapów.
Należą do nich: sprawozdanie, link do kodu oraz program.
Platforma umożliwia umieszczanie dokumentu w dowolnym formacie.
Użytkownicy mogą w intuicyjny sposób przejść do kodu programu powstałego dla zadanego etapu poprzez link prowadzący do odpowiedniego tzw. ”commita” w~systemie kontroli wersji.

Kolejnym zadaniem zespołu jest przeprowadzenie procesu integracji w~ramach projektu.
Proces integracji jest definiowany przez prowadzącego i składa się on z listy kolejnych etapów.
Przeprowadzenie procesu polega na uruchomieniu przez platformę w odpowiedniej kolejności programów studentów załączonych dla wskazanych etapów i~sprawdzenia wyniku.
Aby lepiej przybliżyć koncepcję integracji, jako prosty przykład projektu można byłoby podać projekt mający na celu odwrócenie macierzy.
Mógłby mieć on wyróżnione dwa etapy: pierwszy polegający na wyznaczeniu wyznacznika i drugi służący do obliczenia nowej macierzy na podstawie podanego wyznacznika i macierzy wejściowej.
Po zamieszczeniu programów dla obu etapów można byłoby przeprowadzić proces integracji.
Polegałby on na uruchomieniu pierwszego etapu dla zadanej macierzy wejściowej, a następnie uruchomieniu drugiego etapu dla otrzymanych w kroku pierwszym wyników.
Końcowy wynik zostałby sprawdzony z oczekiwanym wynikiem w ramach testu akceptacyjnego.
Na platformie można definiować procesy integracji składające się maksymalnie z pięciu etapów.

Narzędzie udostępnia studentom wyniki dla przeprowadzonych etapów oraz integracji.
Dla każdego zadania są to pełne, opisane w poprzednim podrozdziale, wyniki testów.
W przypadku już zakończonych etapów oraz integracji studenci mają wgląd do podsumowanego statusu ich pracy, mówiącego o tym ile z testów akceptacyjnych zostało przez nich zaliczone.

Jak zostało wspomniane wcześniej, studenci nie pracują systematycznie.
Aby zmotywować ich do regularnych działań, platforma wprowadza element grywalizacji udostępniając zbiorczy podgląd wyników innych grup.
Dzięki temu studenci mogą sklasyfikować swoje postępy na tle innych.


\section{Konfiguracja środowiska uruchomieniowego}

Studenci przedstawiający manualnie swoje wyniki cząstkowe prowadzącym mogą natrafić obecnie na szereg problemów.
Podczas prezentacji mogą zaistnieć komplikacje związane między innymi z niepoprawną konfiguracją środowiska uruchomieniowego lub niewłaściwym doborem przypadków testowych.
W sytuacji, gdy zadaniem studentów jest zaprezentowanie interakcji pomiędzy stworzonymi przez nich modułami programów, prawdopodobieństwo wystąpienia powyższych błędów wzrasta.
Proponowane narzędzie przechowuje i udostępnia wspólną konfigurację środowiska uruchomieniowego w ramach projektu.
Zapewnia to testowanie aplikacji studenckich na różnych maszynach z takim samym efektem.


\section{Tworzenie grup projektowych}
\label{adding_project_groups}

Wprowadzane narzędzie może zostać zintegrowane z używanym obecnie systemem kontroli wersji.
W myśl tego założenia prowadzący ma możliwość konfiguracji na platformie takich samych grup projektowych jak grupy zdefiniowane w systemie kontroli wersji.
Dodanie zespołów projektowych jest proste i nie wymaga powielania tych samych czynności w obu narzędziach.
Platforma umożliwia wgranie grup bezpośrednio z pliku w formacie JSON, wyeksportowanego wcześniej z systemu kontroli wersji.
Przykład struktury akceptowalnego pliku wygląda następująco:

{\fontfamily{qcr}\selectfont
\footnotesize
\begin{lstlisting}
{
    "groups":[
        {
            "name":"A",
            "students":[
                "Student1",
                "Student2"
            ]
        },
        {
            "name":"B",
            "students":[
                "Student3",
                "Student4"
            ]
        }
    ]
}
\end{lstlisting}
}


\section{Zbieranie statystyk}

W celu lepszego zrozumienia procesu pracy studentów podczas semestru zbierane i~przechowywane są statystyki z~wykonania kolejnych zadań.
Platforma umożliwia zapisywanie prostych danych audytowych, dotyczących każdej z~prób uruchomienia programów w ramach etapu lub integracji.
W skład gromadzonych informacji wchodzą:
\begin{itemize}
    \item identyfikator użytkownika,
    \item data próby,
    \item rezultat, jaki uzyskano w wyniku działania programu.
\end{itemize}
Powyższe informacje są przechowywane przez platformę i dostępne na żądanie prowadzącego.
Opisane wyżej statystyki mogą posłużyć do dalszej analizy procesu pracy studentów i usprawnienia prowadzenia projektów grupowych.


\section{Wymagania niefunkcjonalne}

Proponowane narzędzie jest generyczne.
Prowadzący może zdefiniować w analogiczny sposób wiele projektów, etapów, integracji, grup oraz przypadków testowych.
Obecnie w~ramach programu kształcenia kładzie się nacisk na projekty grupowe.
Proponowane narzędzie jest uniwersalne i umożliwia prostą definicję różnych środowisk uruchomieniowych z dowolną ich konfiguracją.
Pliki konfiguracyjne są udostępnione dla użytkowników.
Takie podejście umożliwia zastosowanie platformy na każdym etapie studiów dla projektów prowadzonych w dowolnym języku programowania.

Zarówno od strony interfejsu użytkownika, jak i prowadzącego narzędzie jest proste i intuicyjne.
Dostępne dla użytkowników widoki wyświetlają minimum niezbędnych informacji i są stworzone w myśl dobrych praktyk UX (ang. User Experience)~\cite{ux-good-practicies}.

Dostęp do funkcjonalności platformy jest zależny od poziomu uprawnień użytkownika.
Prowadzący ma szersze uprawnienia niż student, w tym możliwość pełnej konfiguracji projektów i podglądu danych statystycznych.
Widok studenta ogranicza się do projektów, do których został on przypisany.

Wszystkie wprowadzane przez użytkowników dane dotyczące projektów, grup, integracji oraz etapów są edytowalne.
Wyjątek stanowią kod, program oraz raport dla zadanego etapu.
Ich edycja jest możliwa przez studentów od daty rozpoczęcia do daty zakończenia danej części projektu.
Oba terminy są widoczne dla użytkowników.

Warto zaznaczyć, że umieszczane aplikacje studenckie mogą zawierać istotne błędy powodujące przykładowo wycieki pamięci i nieskończone pętle.
Platforma jest odporna na takie sytuacje i zwróci błąd wykonania danego programu, nie doprowadzając do zawieszenia i zamknięcia całego systemu.

Platforma umożliwia równoległy dostęp dla wielu użytkowników.
Narzędzie jest skalowalne i proste w konfiguracji.
Dzięki temu umożliwia prowadzenie kilku projektów jednocześnie.
Czas uruchamiania platformy oraz przeprowadzania testów akceptacyjnych na programach studentów jest stosunkowo krótki.

Platforma została zaimplementowana jako narzędzie usprawniające prowadzenie projektów grupowych.
Warto jednak zaznaczyć, że może ona również służyć do weryfikacji projektów indywidualnych.
W takim przypadku każda ze zdefiniowanych grup projektowych powinna mieć przypisanego tylko jednego studenta.


\section{Ograniczenia zakresu pracy}

Omawiane narzędzie zostało utworzone jako MVP (ang. Minimal Value Product).
Oznacza to, że podczas implementacji ograniczono się do dodania głównych funkcjonalności, pozwalających na wykorzystanie narzędzia podczas prowadzenia przedmiotu realizującego projekt grupowy.
Pozostałe, dodatkowe funkcjonalności mogą zostać dodane w ramach rozwinięcia pracy.

W wersji MVP nie zakłada się kompilacji kodu studentów bezpośrednio przez narzędzie.
Oczekuje się, że studenci sami zbudują swoje projekty i zamieszczą na platformie wykonywalne programy.

Warto podkreślić, że celem wprowadzenia platformy nie jest eliminacja spotkań z~prowadzącym.
Zastosowanie narzędzia nie dąży również do zastąpienia funkcjonalności systemów do kontroli wersji, których interfejs usprawnia przeglądanie kodu.
Podstawowym zadaniem platformy jest usprawnienie procesu weryfikacji postępów pracy w ramach studenckiego grupowego projektu informatycznego, zarówno dla nauczycieli akademickich, jak i studentów.

Celem pracy nie jest również opracowanie systemu sprawiedliwej oceny członków zespołu.
Platforma może jednak stanowić ważną pomoc w tym procesie.




